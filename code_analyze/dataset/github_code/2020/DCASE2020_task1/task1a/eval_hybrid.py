import numpy as np
import pandas as pd
import keras
from sklearn.metrics import confusion_matrix
from sklearn.metrics import log_loss


# if following probs are used (generated by given pretrained models), 
# should get the final results 
# Val acc:  0.819
# Val log loss: 0.936
# 
# 
# Devices list:  ['a' 'b' 'c' 's1' 's2' 's3' 's4' 's5' 's6']
# Per-device val acc :  [0.879 0.809 0.873 0.818 0.77  0.824 0.83  0.791 0.776]
# Device A acc:  0.879
# Device B & C acc:  0.841
# Device s1 & s2 & s3 acc:  0.804
# Device s4 & s5 & s6 acc:  0.799
# 
# 
# Confusion matrix:
# [[220   0   0  10   0   0  50  17   0   0]
#  [  0 280   6   0   0   0   0   0   0  11]
#  [  0  15 254   1   0   0   0   0   0  27]
#  [ 10   1   2 256   0   0  25   0   0   3]
#  [  0   0   0   0 282  10   0   1   4   0]
#  [  0   0   0   0  48 200   0  21  28   0]
#  [ 38   0   0  17   0   0 240   2   0   0]
#  [ 16   0   0   9   7  26  37 186  16   0]
#  [  0   0   0   0  14   8   0   5 270   0]
#  [  0  29  23   0   1   0   0   0   0 244]]
# Class names: ['airport' 'bus' 'metro' 'metro_station' 'park' 'public_square'
#  'shopping_mall' 'street_pedestrian' 'street_traffic' 'tram']
# Per-class val acc:  [0.741 0.943 0.855 0.862 0.949 0.673 0.808 0.626 0.909 0.822]

prob_3class = np.loadtxt('3class/class3_results_acc0.932.txt')
prob_10class = np.loadtxt('10class/class10_results_acc0.794.txt')

preds = np.zeros(prob_10class.shape)
prob_map = np.zeros(prob_10class.shape[1])

for i in range(prob_3class.shape[0]):
    prob_map[0] = prob_3class[i][0]
    prob_map[1] = prob_3class[i][2]
    prob_map[2] = prob_3class[i][2]
    prob_map[3] = prob_3class[i][0]
    prob_map[4] = prob_3class[i][1]
    prob_map[5] = prob_3class[i][1]
    prob_map[6] = prob_3class[i][0]
    prob_map[7] = prob_3class[i][1]
    prob_map[8] = prob_3class[i][1]
    prob_map[9] = prob_3class[i][2]
    preds[i, :] = prob_10class[i, :] * prob_map

# preds is the final output probabilty 

# get ground truth and do analysis
val_csv = '10class/evaluation_setup/fold1_evaluate.csv'

dev_test_df = pd.read_csv(val_csv,sep='\t', encoding='ASCII')
wav_paths = dev_test_df['filename'].tolist()
ClassNames = np.unique(dev_test_df['scene_label'])
y_val =  dev_test_df['scene_label'].astype('category').cat.codes.values

for idx, elem in enumerate(wav_paths):
    wav_paths[idx] = wav_paths[idx].split('/')[-1].split('.')[0]
    wav_paths[idx] = wav_paths[idx].split('-')[-1]

device_idxs = wav_paths
device_list = np.unique(device_idxs) 

num_classes = 10
y_val_onehot = keras.utils.to_categorical(y_val, num_classes)

y_pred_val = np.argmax(preds,axis=1)

over_loss = log_loss(y_val_onehot, preds)
overall_acc = np.sum(y_pred_val==y_val) / y_val.shape[0]

np.set_printoptions(precision=3)
print("\n\nVal acc: ", "{0:.3f}".format(overall_acc))
print("Val log loss:", "{0:.3f}".format(over_loss))

# get results for each device
device_acc = []
device_loss = []
for device_id in device_list:
    cur_preds = np.array([preds[i] for i in range(len(device_idxs)) if device_idxs[i] == device_id])
    cur_y_pred_val = np.argmax(cur_preds,axis=1)
    cur_y_val_onehot = np.array([y_val_onehot[i] for i in range(len(device_idxs)) if device_idxs[i] == device_id])
    cur_y_val = [y_val[i] for i in range(len(device_idxs)) if device_idxs[i] == device_id]
    cur_loss = log_loss(cur_y_val_onehot, cur_preds)
    cur_acc = np.sum(cur_y_pred_val==cur_y_val) / len(cur_preds)
    
    device_acc.append(cur_acc)
    device_loss.append(cur_loss)
    
print("\n\nDevices list: ", device_list)
print("Per-device val acc : ", np.array(device_acc))
print("Device A acc: ", "{0:.3f}".format(device_acc[0]))
print("Device B & C acc: ", "{0:.3f}".format((device_acc[1] + device_acc[2]) / 2))
print("Device s1 & s2 & s3 acc: ", "{0:.3f}".format((device_acc[3] + device_acc[4] + device_acc[5]) / 3))
print("Device s4 & s5 & s6 acc: ", "{0:.3f}".format((device_acc[6] + device_acc[7] + device_acc[8]) / 3))



# get confusion matrix
conf_matrix = confusion_matrix(y_val,y_pred_val)
print("\n\nConfusion matrix:")
print(conf_matrix)
conf_mat_norm_recall = conf_matrix.astype('float32')/conf_matrix.sum(axis=1)[:,np.newaxis]
#print(conf_mat_norm_recall)
recall_by_class = np.diagonal(conf_mat_norm_recall)
mean_recall = np.mean(recall_by_class)

print("Class names:", ClassNames)
print("Per-class val acc: ",recall_by_class, "\n\n")





